# 0.3 Requirements
    preparation: google chrome(browser), github(version control), node.js, visual studio code(text editor), npm(or yarn)
    react 무료강의, react hooks 10 듣고 오라 함


# 04 Project Setup
    react 설치: $ npx create-react-app vanilla-redux
        - src 폴더 내에서  index.js만 남기고 전부 삭제(App,js, App.css, index.css, logo.svg, serviceWorker.js, setupTests.js 등)

    (index.js)
        전부 지우고 시작

    git init
    git remote add origin https://github.com/Junanjunan/vanilla-redux
    git add .
    git commit -m "sad"
    git push origin master


# 1.0 Vanilla Counter
    (public/index.html)
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
            name="description"
            content="Web site created using create-react-app"
            />
            <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
            <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
            <title>React App</title>
        </head>
        <body>

        </body>
        </html>
        - 주석 지우고 시작

    npm start로 프로젝트 시작

    (public/index.html)
        <body>
            <button id="add">Add</button>
            <span>0</span>
            <button id="minus">Minus</button>
        </body>

    (src/index.js)
        const add = document.getElementById("add");
        const minus = document.getElementById("minus");
        const number = document.querySelector("span");


        let count = 0;

        number.innerText = count;

        const updateText = () => {
            number.innerText = count;
        }

        const handleAdd = () => {
            count = count + 1;
            updateText();
        };

        const handleMinus = () => {
            count = count -1;
            updateText();
        };

        add.addEventListener("click", handleAdd);
        minus.addEventListener("click", handleMinus);
        위와 같은 vanilla JS를 Redux로 교체하자


# 1.1 Store and Reducer
    
    Redux 설치: $ npm install redux

    (src/index.js)
        import { createStore } from "redux";

        const countModifier = () => {            // reducer를 countModifier로 명명 , state 초기값을 주지 않으면 0을 초기값으로 갖는다고 함
            return 1
        }

        const countStore = createStore(countModifier);  // createStore는 reducer를 받아야 한다.() 안에가 reducer, 따라서 reducer를 위에 먼저 정의


# 1.2 Actions

    dispatch(action) -> reducer -> state에서 reture -> (getState 등이 subscribe되어 있다면 자등으로) render

    state를 위해서는 dispatch를 통해야 하고, dispatch는 반드시 action이 필요, action은 object이어야 하고, type을 반드시 가져야 한다.


# 1.4 Recap Refactor

    (index.js)
        import { createStore } from "redux";

        const add = document.getElementById("add");
        const minus = document.getElementById("minus");
        const number = document.querySelector("span");

        const ADD = "ADD";
        const MINUS = "MINUS";

        const countModifier = (count=0, action) => {    // reducer를 countModifier로 명명 , state 초기값을 주지 않으면 0을 초기값으로 갖는다고 함
            switch (action.type){
                case ADD:                               
                    return count +1;
                case MINUS:
                    return count -1;
                default:
                    return count;
            }
        };

        const countStore = createStore(countModifier);  // createStore는 reducer를 받아야 한다.() 안에가 reducer, 따라서 reducer를 위에 먼저 정의

        const onChange = () => {
            number.innerText = countStore.getState();
        }

        countStore.subscribe(onChange);

        const handleAdd = () => {
            countStore.dispatch({ type: "ADD" });
        }

        const handleMinus = () => {
            countStore.dispatch({ type: "MINUS" });  // Actions must be plain objects. -> objects: {type: "a"}
        }

        add.addEventListener("click", handleAdd);   // add.addEventListener("click", () => countStore.dispatch({type:"ADD"})) 
        minus.addEventListener("click", handleMinus);

# 2.0 Vanilla ToDo

    Vanila JavaScript ToDo
    
    (public/index.html)
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
            name="description"
            content="Web site created using create-react-app"
            />
            <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
            <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
            <title>Vanilla Redux</title>
        </head>
        <body>
            <h1>To Doss</h1>
            <form>
            <input type="text" placeholder="Write to do" />
            <button>Add</button>
            </form>
            <ul></ul>
            <script src="../src/index.js"></script>
        </body>
        </html>

    (src/index.js)
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const createToDo = toDo => {
            const li = document.createElement("li");
            li.innerText = toDo;
            ul.appendChild(li);
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            createToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);


    Redux를 이용해서 ToDO를 다시 작성해보자

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const reducer = (state = [], action) => {
            console.log(action);
            switch (action.type) {
                case ADD_TODO:
                    return [];
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            store.dispatch({type:ADD_TODO, text:toDo});
        };

        form.addEventListener("submit", onSubmit);

    똑같이 해줬는데 나는 console.log(action)이 안나오고 오류가 나옴..
    Uncaught SyntaxError: Cannot use import statement outside a module
        -> import {createStore} from "redux";가 안되어서 인듯
        * package.json에 "type":"module" 추가하고, (public/index.html)에서 <script type="module" src="../src/index.js"></script> 해주면 된다고 함
            -> 오류 변경 Access to script at 'file:///C:/Users/User/Desktop/github/redux/vanilla-redux/src/index.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.
                -> https://velog.io/@takeknowledge/%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-CORS-policy-%EA%B4%80%EB%A0%A8-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-3gk4gyhreu
                뭐 어떻게 하라는데, 해도 안됨

    --> 해결
        redux를 쓰려면, npm start를 통해 열린 서버를 통해 실행해야 위 오류가 발생하지 않는다.
        CORS policy 라는게 사용되어지는 데이터?의 출처가 서로 다를때 막는데, 오류가 생긴 이유를 생각해보니, redux는 node 서버에서 돌아가는데(따라서 npm start를 해줘야 실행됨), index.html을 나는 서버 구동없이 그냥 열었기 때문에 CORS 문제가 생긴듯,
        또한, node 서버를 통하니, index.html에서 script를 통해 index.js를 호출하지 않아도 저절로 호출되었음. 오히려 script를 통해 호출했더니 Uncaught SyntaxError: Unexpected token '<' 라는 오류가 발생
        
    --> 어쨌든, redux를 실행할때는 npm start를 통해 node 서버에서 구동해야 함을 알았다. (CORS policy...)

    * 절대 Mutate State 쓰지 말라고 함. 왜인지는 설명 안했음


# 2.1 State Mutation

    Three Principles of Redux

    https://redux.js.org/understanding/thinking-in-redux/three-principles

    1. Single source of truth
    2. State is read-only
    3. Changes are made with pure functions
        Don't mutate state -> state를 그대로 조작하는게 아니라, 새로운 state를 return 한다.

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];   // ...state: ES6 spread
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
            });
        };

        store.subscribe(paintToDos)

        const addToDo = text => {
            store.dispatch({type:ADD_TODO, text});     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            addToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

    
# 2.2 Delete To Do

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = e.target.parentNode.id;
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

        아직 개별적으로 delete 되진 않고, 전부 delete 되는 상태


# 2.3 delete To Do part Two

    * splice(): array의 컨텐츠를 바꾼다. 이는 array를 mutate하는데 우린 state를 mutate 하지 않아야하기 떄문에 우리가 원하는 것이 아니다.
        우리는 새 array를 return하도록 하자
        -> filter 사용. filter() method creates a new array

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    return state.filter(toDo => toDo.id !== action.id); // action.id는 삭제할 li의 id, filter()는 테스트 통과한 거는 남겨두는 method, 따라서 filter test를 해주는 toDo.id는 남겨놓을 li의 id이기 때문에 toDo.id !== action.id! 이어야 한다.
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = parseInt(e.target.parentNode.id);    // HTML으로부터 string으로 넘어올테니까 parseInt를 해주자
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

# 2.4 Conclusions

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    const newToDoObj = { text: action.text, id: Date.now() }
                    return [...state, newToDoObj ];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    const cleaned = state.filter(toDo => toDo.id !== action.id); // action.id는 삭제할 li의 id, filter()는 테스트 통과한 거는 남겨두는 method, 따라서 filter test를 해주는 toDo.id는 남겨놓을 li의 id이기 때문에 toDo.id !== action.id! 이어야 한다.
                    return cleaned;
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = parseInt(e.target.parentNode.id);    // HTML으로부터 string으로 넘어올테니까 parseInt를 해주자
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

## 3 REACT REDUX

# 3.0

    (src/components/App.js) 생성
        function App() {
            return "App"
        }

        export default App;

    (src/index.js)
        import React from "react";
        import ReactDOM from "react-dom";
        import App from "./components/App";

        ReactDOM.render(<App></App>, document.getElementById("root"));

    (public/index.html)
    ...
    <body>
        <div id="root"></div>
    </body>
    ...

    작동하는 것 확인하고 계속 진행 - App 이 html에 표시됨

    필요한 것들 설치
    
        $ npm install react-redux
        $ npm install react-router-dom
        
            Detail과 Home 2개의 페이지가 필요하기 때문이라 함

    (src/routes/Home.js)
        export default () => "Home";

    (src/routes/Detail.js)
        export default () => "Detail";

    (src/components/App.js)
        import React from "react";
        import { HashRouter as Router, Route } from "react-router-dom";
        import Detail from "../routes/Detail";
        import Home from "../routes/Home";

        function App() {
            return (
                <Router>
                    <Route path="/" exact component={Home}></Route>
                    <Route path="/:id" component={Detail}></Route>
                </Router>
            );
        }

        export default App;

    -> http://localhost:3000/# : Home 이 나오고
       http://localhost:3000/#/1, 12312 등 : Detail이 나온다.

    여기까지 기본 셋팅

    (src/routes/Home.js)
        import React, { useState } from "react";

        function Home() {
            const [text, setText] = useState(""); // react hooks useState()
            function onChange(e) {
                setText(e.target.value);
            };
            function onSubmit(e) {
                e.preventDefault();
                setText = "";
            }
            return (
                <>
                    <h1>To do</h1>
                    <form onSubmit={onSubmit}>
                        <input type="text" value={text} onChange={onChange} />
                        <button>Add</button>
                    </form>
                    <ul></ul>
                </>     // <></> is called a Fragment, It's a ReactJS feature. <></> = <Fragment></Fragment> / react는 하나의 태그만 return 되는데 react.fragment는 두개 리턴 시켜준다. 라고 함
            );
        }

        export default Home;    

        <input type="text /> 까지 하면 input에 입력되는데. 우리는 Hooks를 이용해서 값을 받아올것인데, 이때는 onChange를 이용해야함, value={text}를 줬기 때문에 text 값을 받아오려면 onChange를 이용


# 3.1 Connecting the Store

    (src/routes/store.js)
        import { createStore } from "redux";

        const ADD = "ADD";
        const DELETE = "DELETE";

        export const addToDo = text => {
            return {
                type: ADD,
                text
            };
        };

        export const deleteToDo = id => {
            return {
                type: DELETE,
                id
            };
        };

        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD:
                    return [{ text: action.text, id: Date.now() }, ...state];
                case DELETE:
                    return state.filter(toDo => toDo.id !== action.id);
                default:
                    return state;
            }
        }

        const store = createStore(reducer);

        export default store;

    (src/index.js)
        import React from "react";
        import ReactDOM from "react-dom";
        import { Provider } from "react-redux";
        import App from "./components/App";
        import store from "./routes/store";

        ReactDOM.render(
            <Provider store={store}>      
                <App />
            </Provider>,    // (src/routes/store.js)의 store와 연결시켜주기 위해 react-redux의 Provider 사용
            document.getElementById("root")
        );


# 3.2 mapStateToProps

    react-redux의 문서 참고

    connect()
        - component 들을 store에 연결시켜준다.
        - 2개의 argument를 가진다. mapStateToProps, mapDispatchToProps -> 2개 중 고를 수 있다.
    mapStateToProps()
        - store의 state를 Home.js에 연결시켜줄 수 있도록 이용해보자. (Home.js의 getCurrentState())
        - 2개의 argument, state, ownProps? : state - redux의 state, ownProps? - component의 props
        - Redux store로부터 무언가를 가져오기 위해서 사용, 가져와서 component의 props에 넣는다.

    connect()가 Home으로 보내는 props에 추가될 수 있도록 허용해준다.

    (src/routes/Home.js)
        ...
        function getCurrentState(state, ownProps) {
            console.log(state, ownProps);
        }

        export default connect(getCurrentState)(Home);
    
    이렇게 해주고 console을 보면
    mapStateToProps() in Connect(Home) must return a plain object. Instead received undefined.
    라는 오류가 뜨긴 하는데, 중요한 것은 Redux store로부터 state를 받아 오고 있다는 것이다.
    빈 array가 나오는데, 확인을 위해 "Hello"를 default state로 주고 다시 출력해보자.

        어떻게 store를 받아오는가 보니... 아래는 내 생각 정리. 전혀 안맞을 수도 있다.
            store.js 파일(이름은 상관 무)
            index.js에서 <Provider store={store}><App /></Provider> -> Provider를 통해 store와 연결 (store에 대한 정보는 App 안의 component에 담겨있음)
            App.js는 Router, Route를 통해 props를 Home에게 주는데,
            Home.js에서는 mapStateToProps를 통해 props에 store.js의 store의 state를 담아서, connect()를 통해 Home.js에 있는 function Home에 전달...??

            store.js의 store의 state값을 전달하는데
            Provider - Router - Route - Home 이런 식으로 props를 전달하는데, Route-Home에서 mapStateToProp를 통해 store의 state 값을 props에 포함시킨다.


    그리고 {history:{...}, location:{...}, ... } 라고 compoent의 Props가 출력
    이는 react router에 의해서 Home에게 준 Props 이다

    이제 오류를 해결하기 위해 (무언가를) return 해보자.

    (src/routes/Home.js)
        function Home(props){
            console.log(props);
            ...
        }

        ...

        function getCurrentState(state, ownProps){
            return {sexy: true}
        }

        export default connect(getCurrentState)(Home);

        위와 같이 해주고 console을 보면 sexy:true가 props에 담긴게 출력된다.
            -> react router에 의해 Home에게 Props를 준것을 확인 가능
            -> connect()가 Home(즉, component)으로 보내는 props에 추가도힐 수 있도록 허용해 준다.
            -> 이제 App component에는 react-router로부터 받은 props들과 connect를 통해 받은 sexy:true가 담겨있다.

        이를 이용해보자.
        그리고 참고. 우리는 getCurrentState라고 해줬는데, 문서를 보면 mapStateToProps로 해주어야 한다고 한다.
        의미 정리: mapStateToProps - Redux state로부터 component에 prop으로써 전달한다는 것
        이를 통해 toDo를 render할 수 있다.
        일단 render 하지 않고 먼저 봐보자. - JSON을 이용해서

    (src/routes/Home.js)
        import React, { useState } from "react";
        import { connect } from "react-redux";

        function Home({ toDos } {
            const [text, setText] = useState(""); // react hooks useState()
            function onChange(e) {
                setText(e.target.value);
            };
            function onSubmit(e) {
                e.preventDefault();
                setText = "";
            }
            return (
                <>
                    <h1>To do</h1>
                    <form onSubmit={onSubmit}>
                        <input type="text" value={text} onChange={onChange} />
                        <button>Add</button>
                    </form>
                    <ul>{JSON.stringify(toDos)}</ul>
                </>      // <></> is called a Fragment, It's a ReactJS feature. <></> = <Fragment></Fragment> / react는 하나의 태그만 return 되는데 react.fragment는 두개 리턴 시켜준다. 라고 함
            );
        }

        function mapStateToProps(state) { // ownProps는 필요 없어서 삭제
            return { toDos: state }
        }

        export default connect(mapStateToProps)(Home);

    위와 같이 하면 default state 값인 ["Hello"] 가 화면에 나타난다.

    다음 강의는 어떻게 toDo를 추가하는지 보자.


# 3.3 mapDispatchToProps
    connect()는 mapStateToProps와 mapDispatchToProps 2개의 인자를 받는다: connect(mapStateToProps, mapDispatchToProps)
    mapStateToProps만 써도 된다.: connect(mapStateToProps)
    mapDispatchToProps만 쓸때는 이렇게: connect(null, mapDispatchToProps)
    mapDispatchToProps는 2개의 인자를 받는다.: dispatch, ownProps?

    (src/routes/Home.js)
        ...
        function mapDispatchToProps(dispatch){
            return {dispatch}                   // {} 안에 왜 넣는 걸까..
        }

        export default connect(mapStateToProps, mapDispatchToProps)(Home);

    위와 같이 mapDispatchToProps와 Home을 연결해주고,
    dispatch를 Home({ dispatch })로 해서 사용하자

    (src/routes/Home.js)
        import { addToDo } from "./store";

        function Home({ toDos, dispatch }) {
            ...
            function onSubmit(e){
                ...
                dispatch(addToDo({text}))       // store.js에서 addToDo는, {type: Add, text}를 반환하는 action에 들어갈 인자?이다. 자체가 action은 아니고, action으로 넣기위해 만든 인자.
            }
        }

    전체기록
    (src/routes/Home.js)
        import React, { useState } from "react";
        import { connect } from "react-redux";
        import { addToDo } from "./store";

        function Home({ toDos, dispatch }) {
            const [text, setText] = useState("");
            function onChange(e) {
                setText(e.target.value);
            };
            function onSubmit(e) {
                e.preventDefault();
                setText("");
                dispatch(addToDo({text}))
            }
            return (
                <>
                    <h1>To do</h1>
                    <form onSubmit={onSubmit}>
                        <input type="text" value={text} onChange={onChange} />
                        <button>Add</button>
                    </form>
                    <ul>{JSON.stringify(toDos)}</ul>
                </>
            );
        }

        function mapStateToProps(state) { 
            return { toDos: state }
        }

        function mapDispatchToProps(dispatch, ownProps){
            return {dispatch}
        }

        export default connect(mapStateToProps, mapDispatchToProps)(Home);


    mapStateToProps, mapDispatchToProps를 통해 props를 변경해서 넘겨줄 수 있음을 알수 있었다.
    새로운 addToDo라는 prop을 만들자. 위와 같이 dispatch를 Home에 넣고 하지 말고 prop으로 만들자

    우선, action에 들어갈 것들을 묶어서 actionCreators로 만들어주자
    (src/routes/store.js)
        import { createStore } from "redux";

        const ADD = "ADD";
        const DELETE = "DELETE";

        const addToDo = text => {
            return {
                type: ADD,
                text
            };
        };

        const deleteToDo = id => {
            return {
                type: DELETE,
                id
            };
        };

        const reducer = (state = ["Hello"], action) => {
            switch (action.type) {
                case ADD:
                    return [{ text: action.text, id: Date.now() }, ...state];
                case DELETE:
                    return state.filter(toDo => toDo.id !== action.id);
                default:
                    return state;
            }
        }

        const store = createStore(reducer);

        export const actionCreators = {         // 이렇게
            addToDo,
            deleteToDo
        }

        export default store;

    (src/routes/Home.js)
        ...
        function mapDispatchToProps(dispatch, ownProps){
            // console.log(dispatch);   // dispatch(action){~~~} 출력. action을 받는, 내가 알고 있는 그 dispatch이다.
            return {
                addToDo: (text) => dispatch(actionCreators.addToDo(text)) // addToDo: text를 받는 actionCreators.addToDo() 를 action으로 받는 dispatch 
            };
        }

        export default connect(mapStateToProps, mapDispatchToProps)(Home);

    위와 같이 해주고, function Home에서 남아있는 props를 보기 위해 다음과 같이 해주자
    
    (src/routes/Home.js)
        function Home({ toDos, ...rest}){
            console.log(rest);
        }
    
    그러면 console에서 남아있는 props에(rest에) 
    addToDo: text => dispatch(_store_WEBPACK_IMPORTED_MODULLE_@__["actionCreators"].addToDo(texT))
    가 담긴 것을 확인 가능
    지금 우리는 Home에서 dispatch를 하지 않고
    dispatch를 prop안에 담아서 Home에 전달하고 있다.

    (src/routes/Home.js)
        import React, { useState } from "react";
        import { connect } from "react-redux";
        import { actionCreators, addToDo } from "./store";

        function Home({ toDos, addToDo }) {
            const [text, setText] = useState(""); // react hooks useState()
            function onChange(e) {
                setText(e.target.value);
            };
            function onSubmit(e) {
                e.preventDefault();
                addToDo(text);
                setText("");
            }
            return (
                <>
                    <h1>To do</h1>
                    <form onSubmit={onSubmit}>
                        <input type="text" value={text} onChange={onChange} />
                        <button>Add</button>
                    </form>
                    <ul>{JSON.stringify(toDos)}</ul>
                </>      // <></> is called a Fragment, It's a ReactJS feature. <></> = <Fragment></Fragment> / react는 하나의 태그만 return 되는데 react.fragment는 두개 리턴 시켜준다. 라고 함
            );
        }

        function mapStateToProps(state) { // ownProps는 필요 없어서 삭제
            return { toDos: state }
        }

        function mapDispatchToProps(dispatch, ownProps){
            // console.log(dispatch);   // dispatch(action){~~~} 출력. action을 받는, 내가 알고 있는 그 dispatch이다.
            return {
                addToDo: (text) => dispatch(actionCreators.addToDo(text)) // addToDo: text를 받는 actionCreators.addToDo() 를 action으로 받는 dispatch 
            };
        }

        export default connect(mapStateToProps, mapDispatchToProps)(Home);

    위와 같이 하고 텍스트를 add 해주면, [{"text":"2","id":1627493048693},{"text":"1","id":1627493047333},"Hello"] 식으로 store.js의 reducer가 case ADD 일때 return 하는 값의 형태가 추가되는 상태임을 확인 가능
    mapDispatchToProps에서 addToDo: (texT) => dispatch(actionCreators.addToDo(text)) 로 props를 전달
    function Home에서 전달받은 prop중 addToDo를 function onSubmit에 넣기
    addToDo(texT)의 값이 text를 받는 action을 이용해서 dispatch
    dispatch를 하면 reducer가 return 해주는 값을 받게 된다.
    따라서 addToDo(text)를 통해서 받아지는 값은, store.js에 정의해준 addToDo를 action으로 받은 reducer의 return값.       

    이렇게 prop을 전달하는 식으로 하기 때문에
    Home component는 직접 dispatch나 actionCreators를 처리할 필요가 없다. (코드의 간결화를 위해서 이렇게 하는 것인가? 예측가능한 코딩을 위해?)

    다음 강의: toDos를 render해보자


# Deleting To Do