# 0.3 Requirements
    preparation: google chrome(browser), github(version control), node.js, visual studio code(text editor), npm(or yarn)
    react 무료강의, react hooks 10 듣고 오라 함


# 04 Project Setup
    react 설치: $ npx create-react-app vanilla-redux
        - src 폴더 내에서  index.js만 남기고 전부 삭제(App,js, App.css, index.css, logo.svg, serviceWorker.js, setupTests.js 등)

    (index.js)
        전부 지우고 시작

    git init
    git remote add origin https://github.com/Junanjunan/vanilla-redux
    git add .
    git commit -m "sad"
    git push origin master


# 1.0 Vanilla Counter
    (public/index.html)
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
            name="description"
            content="Web site created using create-react-app"
            />
            <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
            <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
            <title>React App</title>
        </head>
        <body>

        </body>
        </html>
        - 주석 지우고 시작

    npm start로 프로젝트 시작

    (public/index.html)
        <body>
            <button id="add">Add</button>
            <span>0</span>
            <button id="minus">Minus</button>
        </body>

    (src/index.js)
        const add = document.getElementById("add");
        const minus = document.getElementById("minus");
        const number = document.querySelector("span");


        let count = 0;

        number.innerText = count;

        const updateText = () => {
            number.innerText = count;
        }

        const handleAdd = () => {
            count = count + 1;
            updateText();
        };

        const handleMinus = () => {
            count = count -1;
            updateText();
        };

        add.addEventListener("click", handleAdd);
        minus.addEventListener("click", handleMinus);
        위와 같은 vanilla JS를 Redux로 교체하자


# 1.1 Store and Reducer
    
    Redux 설치: $ npm install redux

    (src/index.js)
        import { createStore } from "redux";

        const countModifier = () => {            // reducer를 countModifier로 명명 , state 초기값을 주지 않으면 0을 초기값으로 갖는다고 함
            return 1
        }

        const countStore = createStore(countModifier);  // createStore는 reducer를 받아야 한다.() 안에가 reducer, 따라서 reducer를 위에 먼저 정의


# 1.2 Actions

    dispatch(action) -> reducer -> state에서 reture -> (getState 등이 subscribe되어 있다면 자등으로) render

    state를 위해서는 dispatch를 통해야 하고, dispatch는 반드시 action이 필요, action은 object이어야 하고, type을 반드시 가져야 한다.


# 1.4 Recap Refactor

    (index.js)
        import { createStore } from "redux";

        const add = document.getElementById("add");
        const minus = document.getElementById("minus");
        const number = document.querySelector("span");

        const ADD = "ADD";
        const MINUS = "MINUS";

        const countModifier = (count=0, action) => {    // reducer를 countModifier로 명명 , state 초기값을 주지 않으면 0을 초기값으로 갖는다고 함
            switch (action.type){
                case ADD:                               
                    return count +1;
                case MINUS:
                    return count -1;
                default:
                    return count;
            }
        };

        const countStore = createStore(countModifier);  // createStore는 reducer를 받아야 한다.() 안에가 reducer, 따라서 reducer를 위에 먼저 정의

        const onChange = () => {
            number.innerText = countStore.getState();
        }

        countStore.subscribe(onChange);

        const handleAdd = () => {
            countStore.dispatch({ type: "ADD" });
        }

        const handleMinus = () => {
            countStore.dispatch({ type: "MINUS" });  // Actions must be plain objects. -> objects: {type: "a"}
        }

        add.addEventListener("click", handleAdd);   // add.addEventListener("click", () => countStore.dispatch({type:"ADD"})) 
        minus.addEventListener("click", handleMinus);

# 2.0 Vanilla ToDo

    Vanila JavaScript ToDo
    
    (public/index.html)
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="utf-8" />
            <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
            <meta name="viewport" content="width=device-width, initial-scale=1" />
            <meta name="theme-color" content="#000000" />
            <meta
            name="description"
            content="Web site created using create-react-app"
            />
            <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
            <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
            <title>Vanilla Redux</title>
        </head>
        <body>
            <h1>To Doss</h1>
            <form>
            <input type="text" placeholder="Write to do" />
            <button>Add</button>
            </form>
            <ul></ul>
            <script src="../src/index.js"></script>
        </body>
        </html>

    (src/index.js)
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const createToDo = toDo => {
            const li = document.createElement("li");
            li.innerText = toDo;
            ul.appendChild(li);
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            createToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);


    Redux를 이용해서 ToDO를 다시 작성해보자

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const reducer = (state = [], action) => {
            console.log(action);
            switch (action.type) {
                case ADD_TODO:
                    return [];
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            store.dispatch({type:ADD_TODO, text:toDo});
        };

        form.addEventListener("submit", onSubmit);

    똑같이 해줬는데 나는 console.log(action)이 안나오고 오류가 나옴..
    Uncaught SyntaxError: Cannot use import statement outside a module
        -> import {createStore} from "redux";가 안되어서 인듯
        * package.json에 "type":"module" 추가하고, (public/index.html)에서 <script type="module" src="../src/index.js"></script> 해주면 된다고 함
            -> 오류 변경 Access to script at 'file:///C:/Users/User/Desktop/github/redux/vanilla-redux/src/index.js' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, chrome-untrusted, https.
                -> https://velog.io/@takeknowledge/%EB%A1%9C%EC%BB%AC%EC%97%90%EC%84%9C-CORS-policy-%EA%B4%80%EB%A0%A8-%EC%97%90%EB%9F%AC%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0-3gk4gyhreu
                뭐 어떻게 하라는데, 해도 안됨

    --> 해결
        redux를 쓰려면, npm start를 통해 열린 서버를 통해 실행해야 위 오류가 발생하지 않는다.
        CORS policy 라는게 사용되어지는 데이터?의 출처가 서로 다를때 막는데, 오류가 생긴 이유를 생각해보니, redux는 node 서버에서 돌아가는데(따라서 npm start를 해줘야 실행됨), index.html을 나는 서버 구동없이 그냥 열었기 때문에 CORS 문제가 생긴듯,
        또한, node 서버를 통하니, index.html에서 script를 통해 index.js를 호출하지 않아도 저절로 호출되었음. 오히려 script를 통해 호출했더니 Uncaught SyntaxError: Unexpected token '<' 라는 오류가 발생
        
    --> 어쨌든, redux를 실행할때는 npm start를 통해 node 서버에서 구동해야 함을 알았다. (CORS policy...)

    * 절대 Mutate State 쓰지 말라고 함. 왜인지는 설명 안했음


# 2.1 State Mutation

    Three Principles of Redux

    https://redux.js.org/understanding/thinking-in-redux/three-principles

    1. Single source of truth
    2. State is read-only
    3. Changes are made with pure functions
        Don't mutate state -> state를 그대로 조작하는게 아니라, 새로운 state를 return 한다.

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];   // ...state: ES6 spread
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
            });
        };

        store.subscribe(paintToDos)

        const addToDo = text => {
            store.dispatch({type:ADD_TODO, text});     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            addToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

    
# 2.2 Delete To Do

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    return [];
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = e.target.parentNode.id;
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

        아직 개별적으로 delete 되진 않고, 전부 delete 되는 상태


# 2.3 delete To Do part Two

    * splice(): array의 컨텐츠를 바꾼다. 이는 array를 mutate하는데 우린 state를 mutate 하지 않아야하기 떄문에 우리가 원하는 것이 아니다.
        우리는 새 array를 return하도록 하자
        -> filter 사용. filter() method creates a new array

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    return [...state, { text: action.text, id: Date.now() }];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    return state.filter(toDo => toDo.id !== action.id); // action.id는 삭제할 li의 id, filter()는 테스트 통과한 거는 남겨두는 method, 따라서 filter test를 해주는 toDo.id는 남겨놓을 li의 id이기 때문에 toDo.id !== action.id! 이어야 한다.
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = parseInt(e.target.parentNode.id);    // HTML으로부터 string으로 넘어올테니까 parseInt를 해주자
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);

# 2.4 Conclusions

    (src/index.js)
        import { createStore } from "redux";
        const form = document.querySelector("form");
        const input = document.querySelector("input");
        const ul = document.querySelector("ul");

        const ADD_TODO = "ADD_TODO";
        const DELETE_TODO = "DELETE_TODO";

        const addToDo = text => {
            return { type: ADD_TODO, text };     // {text:text} -> {text} 로 표현한 것과 동일
        }

        const deleteToDo = id => {
            return { type: DELETE_TODO, id };
        }


        const reducer = (state = [], action) => {
            switch (action.type) {
                case ADD_TODO:
                    const newToDoObj = { text: action.text, id: Date.now() }
                    return [...state, newToDoObj ];    // ...state: ES6 spread, 두개 순서를 바꾸면 새로작성하는게 먼저 온다 [{ text: action.text, id: Date.now() }, ...state ]
                case DELETE_TODO:
                    const cleaned = state.filter(toDo => toDo.id !== action.id); // action.id는 삭제할 li의 id, filter()는 테스트 통과한 거는 남겨두는 method, 따라서 filter test를 해주는 toDo.id는 남겨놓을 li의 id이기 때문에 toDo.id !== action.id! 이어야 한다.
                    return cleaned;
                default:
                    return state;
            }
        };

        const store = createStore(reducer);

        store.subscribe(() => console.log(store.getState()));

        const paintToDos = () => {
            const toDos = store.getState();
            ul.innerHTML = "";      // 중복되서 추가되는걸 막기 위해
            toDos.forEach(toDo => {
                const li = document.createElement("li");
                const btn = document.createElement("button");
                btn.innerText = "DEL";
                btn.addEventListener("click", dispatchDeleteToDo);
                li.id = toDo.id;
                li.innerText = toDo.text;
                ul.appendChild(li);
                li.appendChild(btn);
            });
        };

        store.subscribe(paintToDos)

        const dispatchAddToDo = text => {
            store.dispatch(addToDo(text));     // {text:text} -> {text} 로 표현한 것과 동일
        };

        const dispatchDeleteToDo = (e) => {
            // console.log(e.target);      // <button>DEL</button> 으로 e.target이 출력, 우리는 target의 parentNode를 알아야 한다.
            // console.log(e.target.parentNode); // <li id="~~">...</li> 출력 -> 하는 이유는 삭제할 todo의 id가 필요하기 때문
            // console.log(e.target.parentNode.id); // 이렇게 하면 id 값만 출력 이를 이용
            const id = parseInt(e.target.parentNode.id);    // HTML으로부터 string으로 넘어올테니까 parseInt를 해주자
            store.dispatch(deleteToDo(id));
        };

        const onSubmit = e => {
            e.preventDefault();
            const toDo = input.value;
            input.value = "";
            dispatchAddToDo(toDo);
        };

        form.addEventListener("submit", onSubmit);